#version 120

// Interpolated values from the vertex shaders
//varying vec2 UV;

// Values that stay constant for the whole mesh.
//uniform sampler2D myTextureSampler;

//varying vec3 fragmentColor;
varying vec3 normalColor;


layout(std430, binding=9) buffer OutputBuffer {
  rmTriangle triangles[];
}trBuffer;

void main()
{
//    gl_FragColor = vec4(1,1,1,1);
    gl_FragColor = vec4(normalColor.r,normalColor.g,normalColor.b,1);//vec4(fragmentColor*texture2D( myTextureSampler, UV ).rgb, 1);
//    gl_FragColor = vec4(fragmentColor.r,fragmentColor.g,fragmentColor.b,1);//vec4(fragmentColor, 1);
    
}



#version 430
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

void main() {
  // base pixel colour for image
  vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);
  // get index in global work group i.e x,y position
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

  //
  // interesting stuff happens here later
  //

  // output to a specific pixel in the image
  imageStore(img_output, pixel_coords, pixel);
}


layout( std140, binding=7 ) buffer { atomic_uint bounceCount };
if (IsInsideSphere( pp, SPHERE ) )
{
vp = BounceSphere( p, v, SPHERE );
pp = p + vp*DT + .5*DT*DT*G;
atomicCounterIncrement( bounceCount );
}

